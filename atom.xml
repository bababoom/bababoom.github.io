<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Record</title>
  
  <subtitle>record</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-23T09:29:48.434Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>bao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/12/23/hello-world/"/>
    <id>http://yoursite.com/2018/12/23/hello-world/</id>
    <published>2018-12-23T09:29:48.434Z</published>
    <updated>2018-12-23T09:29:48.434Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于数据库</title>
    <link href="http://yoursite.com/2018/07/26/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/26/关于数据库/</id>
    <published>2018-07-26T01:41:07.000Z</published>
    <updated>2018-07-26T09:25:15.002Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库系统的三级数据模式结构"><a href="#数据库系统的三级数据模式结构" class="headerlink" title="数据库系统的三级数据模式结构"></a>数据库系统的三级数据模式结构</h3><ul><li><p>三级模式<br>1、模式：模式也称为逻辑模式，是对数据库中数据的整体逻辑结构和特征的描述。逻辑模式使用模式DDL定义，定义的内容不仅包括对数据库的记录型、数据项的型、记录间的联系等的描述，同时包括对数据的安全性定义、数据应满足的完整性条件和数据寻址方式的说明。逻辑模式是对所有用户的数据进行综合抽象得到的统一的全局数据视图。一个数据库系统只能有一个逻辑模式。<br>2、外模式：外模式也称子模式，是对各个用户或程序所涉及到的数据的逻辑结构和数据特征的描述。使用子模式DDL定义，该定义涉及对子模式的数据结构、数据域、数据构造规则及数据安全性和完整性等属性的描述。<br>外模式是完全按照用户自己对数据的需要，站在局部的角度进行设计的。由于一个数据库系统有多个用户，所以就有可能有多个数据外模式。外模式是面向用户或程序设计的，所以被称为用户数据视图。从逻辑关系上看，外模式是模式的一个逻辑子集，从一个模式（逻辑模式）可以推导出多个不同的外模式。显然用户数据库是概念数据库的部分抽取。<br>3、内模式：内模式也叫存储模式或物理模式。内模式是对数据的内部表示或底层描述。内模式使用内模式DDL定义。内模式DDL不仅能定义数据的数据项、记录、数据集、索引和存取路径在内的一切物理组织方式等属性，同时还要规定数据的优化性能、响应时间和存储空间需求，规定数据的记录位置、块的大小与数据溢出区等。<br>用户数据库、概念数据库和物理数据库三者的关系是：用户数据库是概念数据库的子集，也是物理数据库子集的逻辑描述。<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-26-1.gif" alt="enter description here"></p></li><li><p>两级映像<br>数据库系统的二级映像技术是指外模式与逻辑模式之间的映像、逻辑模式与外模式之间的映像技术，二级映像技术不仅在三级模式之间建立了联系，同时保证了数据的独立性。<br>1、外模式/逻辑模式之间的映像及作用<br>外模式/逻辑模式之间的映像，定义并保证了外模式与逻辑模式之间的对应关系。外模式/逻辑模式的映像通常保存在外模式中。当逻辑模式变化时，DBA可以修改映像的方法使外模式不变；由于程序是根据外模式进行设计的，只要爱模式不改版，应用程序就不需要修改。使得用户能按外模式 进行程序设计，同时保证了数据的逻辑独立性。<br>2、逻辑模式/内模式的映像及作用<br>逻辑模式/内模式之间的映像，定义并保证了数据的逻辑模式与内模式之间的对应关系，说明数据的记录、数据项在计算机内部是如何组织和表示的。当数据库的存储结构改变时，DBA可以通过修改逻辑模式/内模式之间的映像是数据模式不变化。由于用户或程序是按数据的逻辑模式使用数据的，所以只要数据模式不变，用户仍可以按照原来的方式使用数据，程序也不用修改。逻辑模式/内模式的映像技术不仅使用户或程序能够按数据的逻辑结构使用数据，还提供了内模式变化而程序不变的方法，从而保证了数据的物理独立性。</p></li></ul><h3 id="关系数据模型的名词解释"><a href="#关系数据模型的名词解释" class="headerlink" title="关系数据模型的名词解释"></a>关系数据模型的名词解释</h3><p>1、关系：一个关系对应通常所说的一张二维表。<br>2、元祖：表中的一行称为一个元祖<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-26-2.png" alt="enter description here"><br>3、属性：表中的一列称为一个属性。一个表中往往有多个属性，为了区分属性，要给每个列器一个属性名。同一个表中的属性应具有不同的属性名，属性也称为列或字段。<br>4、码：表中的某个列或列组，它们的值可以唯一的确定一个元祖，且列组中不含多余的列，这样的列组或列称为关系的码。<br>5、域：列额取值范围称为域。（例如：学生年龄的域一般为16-35）<br>6、分量：元组中的一个列值称为分量<br>7、关系模式：关系的型称为福安息模式，关系模式是对关系的描述。关系模式的一般表示是：关系名（列1，列2，…）</p><h3 id="实体联系的类型"><a href="#实体联系的类型" class="headerlink" title="实体联系的类型"></a>实体联系的类型</h3><ul><li>两个实体之间的联系<br>  1、一对一（1:1）：设有两个实体集A和B，如果实体集A与实体集B之间具有一对一联系，则：对于实体集A中的每个实体，在实体集B中最多有一个（或者没有）实体与之联系；反之，对于实体集B中的每个实体，实体集A也最多有一个与之联系。例如：在一个工厂里面只有一个厂长，一个厂长也只能在一个工厂任职，厂长和工厂之间具有1:1联系。<br>  2、一对多（1：n）：设有两个实体集A和B，如果实体集A与实体集B之间具有一对多联系，则：对于实体集A的每个实体，实体集B中有一个或者多个实体与之联系；而对于实体集B中的每个实体，实体集A中最多有一个实体与之联系。例如：一个学校有多个老师，每个老师只能在一个学校任职。学校和老师之间具有1：n联系。<br>  3、多对多联系（m:n)：设有两个实体集A和B，如果实体集A与实体集B之间具有多对多联系，则：对于实体集A的每个实体，实体集B中有一个或多个实体与之联系；反之，对于实体集B中的每个实体，实体集A中也有一个或多个实体与之联系。例如：工厂里的一个职工可以参加多种体育组织，。而一个体育组织也可以有多名职工，体育组织和职工之间就具有m:n的联系。</li><li>三个或三个以上的实体之间的联系<br>1、一对多：设实体集E1、E2、E3…En，如果Ej(j=1,2…n)与其他实体集E1,E2,E3…Ej-1,Ej+1,…En之间存在有一对多联系，则对于Ej中的一个给定实体，可以与其他实体集Ei(i!=j)中的一个或多个实体联系，而实体集Ej(i!=j)中的一个实体最多至欧鞥与Ej中的一个实体联系，则称Ej与E1,E2,…Ej-1,Ej+1,…En之间的联系是一对多的。<br>2、多对多：在两个以上的多个实体集之间，当一个实体集与其他实体集之间均存在多对多联系，而其他实体集之间没有联系时，这种联系称为多对多联系。<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-26-3.png" alt="enter description here"></li></ul><h3 id="信息模型向关系模型的转换"><a href="#信息模型向关系模型的转换" class="headerlink" title="信息模型向关系模型的转换"></a>信息模型向关系模型的转换</h3><p>将E-R图转换成关系模型要解决两个问题：一是如何将实体集和实体键的联系转换成关系模式，二是如何确定这些关系模式的属性和码。关系模型的逻辑结构是一组关系模式，而E-R图则是由实体集、属性以及联系三要素组成。<br>1、实体集的转换规则<br>信息模型中的一个实体集转换成关系模型中的一个关系，实体的属性就是关系的属性，实体的码就是关系的码，关系的结构是关系模式。<br>2、实体集间联系的转换规则</p><ul><li><p>1:1联系的转换方法<br>  一个1:1联系可以转换为一个独立的关系，也可以与任意一端实体集所对应的关系合并。如果将1:1联系转换成一个独立的关系，则与该联系相连的各实体的码以及联系本身属性均转换为关系的属性，且每个实体的码均是该关系的候选码。如果将1:1联系与某实体集所对应的关系合并，则需要在被合并关系中增加属性，其新增的属性为联系本身的属性和与联系相关的另一个实体集的码。<br>  举个栗子<br>  ：<img src="http://osyvt66as.bkt.clouddn.com/2018-07-26-4.png" alt="enter description here"></p><p>  这个栗子有三种方案(加粗的属性为码）</p></li><li><ul><li>方案一：联系形成独立关系，关系模型为<br>职工（<strong>职工号</strong>，姓名，年龄）<br>产品（<strong>产品号</strong>，产品名，价格）<br>负责（<strong>职工号</strong>，<strong>产品号</strong>）</li></ul></li><li><ul><li>方案二：“负责”与“职工“两关系合并<br>职工（<strong>职工号</strong>，姓名，年龄，产品号）<br>产品（<strong>产品号</strong>，产品名，价格）</li></ul></li><li><ul><li>方案三：“负责”与“产品”关系合并<br>职工（<strong>职工号</strong>，姓名，年龄）<br>产品（<strong>产品号</strong>，产品名，价格，职工号）</li></ul></li></ul><p>将上面三种方案进行比较，方案一中因为关系多，增加了系统的复杂性，方案二由于不是每个职工都负责产品，就会造成产品号属性的NULL值过多，而方案三比较合理。在实际转换过程中，因根据具体的情况决定如何转换。</p><ul><li>1：n联系的转换方法<br>有两种方法：1、将联系转换成一个独立的关系，其关系的属性有与该联系相连的个实体集的码以及联系本身属性组成，而该关系的码为n端实体集的码。2、在n端实体集中增加新属性，新属性由联系对应的1端实体集的码和联系自身联系的属性构成，新增属性后原关系的码不变。<br>举例子：<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-26-5.png" alt="enter description here"><br>第一个转换：<ul><li><ul><li>方案一：联系形成独立关系<br>仓库（<strong>仓库号</strong>，地点，面积）<br>产品（<strong>产品号</strong>，产品名，数量）<br>仓储（仓库号，<strong>产品号</strong>，数量）</li></ul></li><li><ul><li>方案二：联系形成的关系与n端合并<br>仓库（<strong>仓库号</strong>，地点，面积）<br>产品（<strong>产品号</strong>，产品名，价格，仓库号，数量）<br>第二个图的同实体集的1:n联系转换为关系模型</li></ul></li><li><ul><li>方案一：合并<br>职工（<strong>职工号</strong>，姓名，年龄，领导工号）</li></ul></li><li><ul><li>方案二：转换为两个关系模式<br>职工（<strong>职工号</strong>，姓名，年龄）<br>领导（领导工号，工号，<strong>职工号</strong>）<br>在这个例子中，第二种方案关系少，且能充分表达原有的数据联系，所以第二种更佳。</li></ul></li></ul></li></ul><ul><li><p>m:n联系的转换方法<br>将一个m:n的联系转换为一个关系，方法为：与该联系相连的各实体集的码以及联系本身的属性均转换为关系的属性，信管系的码为两个相连实体码的组合（该码为多属性构成的组合码）<br>例子：<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-26-6.png" alt="enter description here"><br>第一张图：<br> 学生（<strong>学号</strong>，姓名，年龄，性别）<br> 课程（<strong>课程号</strong>，课程名，学时数）<br> 选修（<strong>学号</strong>，<strong>课程号</strong>，成绩）<br>第二张图同实体集间的m:n联系转换为关系模式<br>  零件（<strong>零件号</strong>，名称，价格）<br>  组装（<strong>组装件号</strong>，<strong>零件号</strong>，数量）</p></li><li><p>三个火三个以上实体集间的多元联系转换方法</p></li><li><ul><li>1：n多元联系：<br>修改n端实体集对应的关系，将于联系相关的1端实体集的码和联系自身的属性作为新属性加入到n端实体集中。</li></ul></li><li><ul><li>多对多的多元联系<br>新建一个独立的关系，该关系的属性为多元联系相连的个实体的码以及联系本身的属性，码为各实体码的组合。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据库系统的三级数据模式结构&quot;&gt;&lt;a href=&quot;#数据库系统的三级数据模式结构&quot; class=&quot;headerlink&quot; title=&quot;数据库系统的三级数据模式结构&quot;&gt;&lt;/a&gt;数据库系统的三级数据模式结构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;三级模式&lt;br&gt;1、模式：
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浅谈对IOC和DI的认识</title>
    <link href="http://yoursite.com/2018/07/17/%E6%B5%85%E8%B0%88%E5%AF%B9IOC%E5%92%8CDI%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/07/17/浅谈对IOC和DI的认识/</id>
    <published>2018-07-17T01:52:15.000Z</published>
    <updated>2018-07-26T09:34:44.854Z</updated>
    
    <content type="html"><![CDATA[<p>对于IOC（Inversion of Control，控制反转）和DI（Dependency Injection，依赖注入）这两个基本的概念，看了书看了视频的讲解还是有点说不清道不明，迷迷糊糊的，上网看了一些人的理解，终于看到了一个很形象的说法，于是恍然大悟。</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。传统的程序设计当中，如果我们需要使用一个对象的时候，多半会直接用new 构造一个对象或者从JNDI中查询一个，使用结束后再进行销毁处理，这样做有一个十分明显的不好的地方，对象和类或接口的耦合度太高。<br> 而Spring所倡导的开发方式是：所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。<br> 举一个简单的例子：<br> 定义一个简单的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后用一个类实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;&#125; ;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置一下相应的xml文件（为了方便将xml文件直接放在 了包路径下面）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"com.Test"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来编写一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 老方法</span></span><br><span class="line"><span class="comment"> * Person per = new Test() ;</span></span><br><span class="line"><span class="comment"> * per.print() ;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//读取xml文档信息</span></span><br><span class="line">String xml = <span class="string">"com/applicationcontextxml.xml"</span> ;</span><br><span class="line">ApplicationContext app = <span class="keyword">new</span> ClassPathXmlApplicationContext(xml) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过getBean方法获取对象</span></span><br><span class="line">Person per = (Person) app.getBean(<span class="string">"test"</span>) ;</span><br><span class="line">per.print();</span><br><span class="line"><span class="comment">//通过配置xml文档来实现不直接使用构造器构造类的实例通过ApplicationContext创建ClassPathXmlApplicationContext来获得xml</span></span><br><span class="line"><span class="comment">//输出Hello world！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>需要对象依赖的时候配置xml方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"com.Test"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ref==reference 引用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--假设Test对象需要Address对象的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.Address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"china"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于IOC（Inversion of Control，控制反转）和DI（Dependency Injection，依赖注入）这两个基本的概念，看了书看了视频的讲解还是有点说不清道不明，迷迷糊糊的，上网看了一些人的理解，终于看到了一个很形象的说法，于是恍然大悟。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java动态代理机制</title>
    <link href="http://yoursite.com/2018/07/13/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/13/Java动态代理机制/</id>
    <published>2018-07-13T04:41:17.000Z</published>
    <updated>2018-07-13T06:19:26.053Z</updated>
    
    <content type="html"><![CDATA[<p>代理是Java SE1.3新增的特性，利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。<br>假设有一个表示接口的Class对象（有可能只包含一个接口），它的确切类型在编译时无法知道。要想构造一个实现这些接口的类，就需要使用newInstance方法或反射找出这个类的构造器。但是不能实例化一个接口，需要在程序处于运行状态的时候定义一个新类。为了解决这个问题，有些程序将会生成代码；将这些代码放置在一个文件中；调用编译器；热庵后再加载结果类文件。这样的做法速度比较慢。而代理机制则是一个更好的解决方案。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。它具有以下方法：<br>1、指定接口所需要实现的全部方法<br>2、Object类中的全部方法<br>当然不是在运行时定义这些方法的代码。而是提供一个调用处理器（invocation handler）。调用处理器是实现了InvocationHandler接口的类对象，这个接口中最重要的方法是：<code>Object invoke(Object proxy,Method method,Object[] args)</code>，当你调用代理对象的方法，调用处理器的invoke都会被调用，并向其传递Method和原始的调用参数，由调用处理器来给出处理调用的方式。</p><h3 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h3><p>Proxy类有一个静态方法<code>Object getProxyClass(ClassLoader loader, Class[] class,InvocationHandler handler);</code><br>这个类有三个参数：1、类加载器：作为Java安全模型的一部分，对于系统类和从因特网上下载的类，可以使用不同的类加载器。使用null表示默认的类加载器<br>2、Class对象数组：每个元素都是需要实现的数组<br>3、一个调用处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被代理的对象</span></span><br><span class="line">Object t = <span class="keyword">new</span> proxyTest() ;</span><br><span class="line"><span class="comment">//调用处理器</span></span><br><span class="line">InvocationHandler h = <span class="keyword">new</span> TraceHandler(t) ;</span><br><span class="line"><span class="comment">//生成代理对象</span></span><br><span class="line">Test p = (Test) Proxy.newProxyInstance(h.getClass().getClassLoader(), <span class="keyword">new</span> Class[]&#123;Test.class&#125;, h) ;</span><br></pre></td></tr></table></figure><h3 id="定义一个调用处理器"><a href="#定义一个调用处理器" class="headerlink" title="定义一个调用处理器"></a>定义一个调用处理器</h3><p>动态代理中有一个十分重要的接口：InvocationHandler<br>定义一个类实现这个接口，并定义这个接口的invoke即可当做一个调用处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object target ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TraceHandler</span><span class="params">(Object t)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.target = t ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.print(target.getClass()+<span class="string">"."</span>+method.getName()+<span class="string">"("</span>);</span><br><span class="line"><span class="keyword">if</span>(args!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">System.out.print(args[i]);</span><br><span class="line"><span class="keyword">if</span>(i&lt;args.length-<span class="number">1</span>)System.out.print(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">")"</span>);</span><br><span class="line"><span class="comment">//调用真正对象中的方法</span></span><br><span class="line"><span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理可以解决很多问题：比如1、路由对远程服务器的方法调用<br>2、在程序运行期间，将用户接口事件与动作关联起来<br>3、可以用作调试，跟踪方法的调用</p><p>跟踪方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Integer实现了Comparable接口</span></span><br><span class="line"><span class="comment"> * 创建对Integer的代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Object[] ele = <span class="keyword">new</span> Object[<span class="number">1000</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">Integer value = i+<span class="number">1</span> ;</span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> TraceHandler(value) ;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(handler.getClass().getClassLoader(), <span class="keyword">new</span> Class[]&#123;Comparable.class&#125;, handler) ;</span><br><span class="line">ele[i] = proxy ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成一个随机数</span></span><br><span class="line">Integer k = <span class="keyword">new</span> Random().nextInt(ele.length+<span class="number">1</span>) ;</span><br><span class="line"><span class="comment">//使用二分查找</span></span><br><span class="line"><span class="keyword">int</span> result = Arrays.binarySearch(ele, k) ;</span><br><span class="line"><span class="keyword">if</span>(result &gt;= <span class="number">0</span>)System.out.println(ele[result]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.compareTo(420)</span></span><br><span class="line"><span class="comment">class java.lang.Integer.toString()</span></span><br><span class="line"><span class="comment">420</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>在这段代码中Integer实现了Comparable接口，代理对象属于在运行时定义的类（它有一个名字如：$Proxy0）这个类也实现了Comparable接口。他的CompareTo方法调用了对象处理器的invoke方法。</p><h3 id="代理类的特性"><a href="#代理类的特性" class="headerlink" title="代理类的特性"></a>代理类的特性</h3><p>代理类是在程序运行过程中创建的，然而一旦创建就变成了普通类，与虚拟机中的任何其他类没什么区别。<br>所有的代理类都扩展与Proxy类。一个代理类只有一个实例域——调用处理器，它定义在Proxy的超类中。为了履行代理对象的职责，所需要的任何附加数据域都必须存储在调用处理器中。例如上段程序中当我们代理Comparable独享时，TraceHandler包装了实际的对象。<br>所有的代理类都覆盖了Object类中的方法toString、equals、hashCode。如同所有的代理方法一样，这些方法仅仅调用了调用处理器的invoke。Object类中的其他方法没有重新定义。<br>没有定义代理类的名字，sun虚拟机中的Proxy类将生成一个以字符串$Proxy开头的类名。<br>对于特定的类加载器和预设的一组接口来说，只能有一个代理类。也就是说如果使用同一个类加载器和接口数组调用两次newProxyInstance方法的话，那么只能够得到同一个类的两个对象，也可以利用getProxyClass方法获得这个类：<code>Class ProxyClass = Proxy.getProxyClass(null,interfaces)</code><br>代理类一定是public和final。如果代理类实现的所有接口都是public，代理类就不属于某个特定的包；否则，所有非公有的接口都必须属于同一个包，同时代理类也属于这个包。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代理的过程简单来说就是：在你用代理对象调用接口中的或者toString、equals、hashCode方法时，都是通过调用处理器的invoke方法处理的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代理是Java SE1.3新增的特性，利用代理可以在运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。&lt;br&gt;假设有一个表示接口的Class对象（有可能只包含一个接口），它的确切类型在编译时无法知道。要想构造一个实现这些接口
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java反射</title>
    <link href="http://yoursite.com/2018/07/10/Java%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2018/07/10/Java反射/</id>
    <published>2018-07-10T04:22:47.000Z</published>
    <updated>2018-07-10T08:11:56.032Z</updated>
    
    <content type="html"><![CDATA[<p>反射库(reflection library)提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。特别是在设计或运行中添加类时，能够快速地应用开发工具动态地查询新添加类的能力。<br>能够分析类能力的程序称为反射(reflective)，反射机制的功能极其强大，在下面可以看到，反射机制可以用来：<br>1、在运行中分析类的能力<br>2、在运行中查看对象<br>3、实现通用的数组操作代码<br>4、利用Method对象</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择对应的方法执行。<br>然而可以通过专门的Java类访问这些信息，保存这些信息的类称为<strong>Class</strong>，Object类中的getClass()方法将返回一个Class类型的实例。</p><p>一个Class对象将表示一个特定类的属性，最常用的Class方法是getName()。这个方法将返回类的名字，如果类在一个包里，包的名字也作为类名的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化一个Student类</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"peter"</span>,<span class="number">18</span>,<span class="string">"177717"</span>) ;</span><br><span class="line"><span class="comment">//getClass()得到类的Class对象并调用getName()方法得到类名并输出</span></span><br><span class="line">System.out.println(stu.getClass().getName());</span><br><span class="line">System.out.println(<span class="keyword">new</span> Date().getClass().getName());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * Test.Student</span></span><br><span class="line"><span class="comment">java.util.Date</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>还可以调用静态方法forName获得类名对应的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String className = <span class="string">"Student"</span> ; </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class cl = Class.forName(className) ;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类名保存在字符串中，并可在运行中改变，就可以使用这个方法。不过className是类名或者接口名时才能执行，否则会抛出一个checked Exception。</p><p>还有一种获得Class对象的方法。如果T是任意的Java类型，T.class将代表匹配的类对象，例如：<code>Class cl1 = int.class ;</code><br>注意：一个class对象实际上表示的是一个类型，而这个类型未必一定是一种类。比如Int不是类，但int.class确是一个Class类型的对象。</p><p>虚拟机只为每个类型管理一个Class对象。因此多个对象调用getClass得到的Class对象其实是同一个，所以我们可以利用==运算符来实现两个类对象比价的操作。<br>还有一个方法newInstance()，可以用来快速创建一个类的实例，这个方法调用默认的构造器生成实例，如果没有默认的构造器就会抛出一个异常，将forName和newInst配合使用就可以根据存储在字符串中的类名创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class cl = Class.forName(<span class="string">"Test.Student"</span>) ;</span><br><span class="line"><span class="comment">//通过newInst方法调用默认构造器生成实例</span></span><br><span class="line">Student stu = (Student) cl.newInstance() ;</span><br><span class="line">stu.age = <span class="number">18</span> ;</span><br><span class="line">stu.name = <span class="string">"tom"</span> ;</span><br><span class="line">System.out.println(stu.name+<span class="string">" "</span>+stu.age);</span><br><span class="line"><span class="comment">//输出：tom 18</span></span><br></pre></td></tr></table></figure><p>如果需要使用带参数的构造器的话，就需要使用Constructor类中的newInstance方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Student类的Class对象</span></span><br><span class="line">Class cl = Class.forName(<span class="string">"Test.Student"</span>) ;</span><br><span class="line"><span class="comment">//获取Constructor类</span></span><br><span class="line">Constructor con = cl.getConstructor(<span class="keyword">new</span> Class[]&#123;String.class,<span class="keyword">int</span>.class,String.class&#125;) ;</span><br><span class="line"><span class="comment">//通过Constructor调用有参数的构造器生成student对象</span></span><br><span class="line">Student stu = (Student) con.newInstance(<span class="string">"tom"</span>,<span class="number">18</span>,<span class="string">"17671"</span>) ;</span><br><span class="line"></span><br><span class="line">System.out.println(stu.name+<span class="string">" "</span>+stu.age+<span class="string">" "</span>+stu.getId());</span><br><span class="line"><span class="comment">//输出: tom 18 17671</span></span><br></pre></td></tr></table></figure><p>总结：获取Class对象一共有三种方式：<br>1、对象调用getClass方法<br>2、对任意类型调用class例如：String.class<br>3、使用Class静态方法forName（ClassName）</p><h3 id="利用反射检查类的结构"><a href="#利用反射检查类的结构" class="headerlink" title="利用反射检查类的结构"></a>利用反射检查类的结构</h3><p>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。这三个类都有getName的方法，用来返回项目的名称。Field类有一个getType方法，用来返回描述域所属类型的Class对象。Method和Constructor类有能够报告参数类型的方法，Method类还有一个可以报告返回类型的方法。这三个类还有一个叫getModifiers的方法，它将返回一个整型数值，用不同的位开关描述public、private、这样的修饰符的使用状况，可以使用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整数值。可以使用Modifier类中的isPublic\isPrivate等方法判断方法或构造器是否是public、private的。我们需要做的就是调用Modifier类相关的方法，并对返回的整数值进行分析。并且还可以通过Modifier.toString方法将修饰符打印出来。</p><p>Class类中的getFields、getMethods和getConstructors方法分别返回类提供的public域、方法和构造器数组，其中包含超类的公有成员。Class类的getDeclaredFields、getDeclaredMethods和getDeclaredConstructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//获取Student类的Class对象</span></span><br><span class="line">Class cl = Class.forName(<span class="string">"Test.Student"</span>) ;</span><br><span class="line"><span class="comment">//获取域、方法、构造器的对象数组</span></span><br><span class="line">Field[] f = cl.getDeclaredFields() ;</span><br><span class="line">Method[] m = cl.getDeclaredMethods() ;</span><br><span class="line">Constructor[] c = cl.getDeclaredConstructors() ;</span><br><span class="line"><span class="comment">//输出类名</span></span><br><span class="line">System.out.println(<span class="string">"public class Student&#123;"</span>);</span><br><span class="line"><span class="comment">//输出域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;f.length;i++)&#123;</span><br><span class="line">Class type=f[i].getType() ;</span><br><span class="line">String name = f[i].getName() ;</span><br><span class="line">System.out.print(<span class="string">"    "</span>);</span><br><span class="line">String mo = Modifier.toString(f[i].getModifiers()) ;</span><br><span class="line"><span class="keyword">if</span>(mo.length()&gt;<span class="number">0</span>)System.out.print(mo+<span class="string">" "</span>);</span><br><span class="line">System.out.println(type.getName()+<span class="string">" "</span>+name+<span class="string">" ;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出构造器</span></span><br><span class="line"><span class="keyword">for</span>(Constructor con:c)&#123;</span><br><span class="line">String name = con.getName() ;</span><br><span class="line">System.out.print(<span class="string">"    "</span>);</span><br><span class="line">String mo = Modifier.toString(con.getModifiers()) ;</span><br><span class="line"><span class="keyword">if</span>(mo.length()&gt;<span class="number">0</span>)System.out.print(mo+<span class="string">" "</span>);</span><br><span class="line">System.out.print(name+<span class="string">"("</span>);</span><br><span class="line">Class[] param = con.getParameterTypes() ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;param.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)System.out.print(<span class="string">","</span>);</span><br><span class="line">System.out.print(param[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">") ;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出方法</span></span><br><span class="line"><span class="keyword">for</span>(Method me:m)&#123;</span><br><span class="line">Class type = me.getReturnType() ;</span><br><span class="line">String name = me.getName() ;</span><br><span class="line">System.out.print(<span class="string">"    "</span>);</span><br><span class="line">String mo = Modifier.toString(me.getModifiers()) ;</span><br><span class="line"><span class="keyword">if</span>(mo.length()&gt;<span class="number">0</span>)System.out.print(mo+<span class="string">" "</span>);</span><br><span class="line">System.out.print(type.getName()+<span class="string">" "</span>+name+<span class="string">"("</span> );</span><br><span class="line"></span><br><span class="line">Class[] param = me.getParameterTypes() ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;param.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span>)System.out.print(<span class="string">","</span>);</span><br><span class="line">System.out.print(param[i].getName());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">") ;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*输出:</span></span><br><span class="line"><span class="comment"> * public class Student&#123;</span></span><br><span class="line"><span class="comment">    private java.lang.String id ;</span></span><br><span class="line"><span class="comment">    public Test.Student() ;</span></span><br><span class="line"><span class="comment">    public Test.Student(java.lang.String,int,java.lang.String) ;</span></span><br><span class="line"><span class="comment">    public java.lang.String getId() ;</span></span><br><span class="line"><span class="comment">    public void setId(java.lang.String) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在运行时通过反射分析对象"><a href="#在运行时通过反射分析对象" class="headerlink" title="在运行时通过反射分析对象"></a>在运行时通过反射分析对象</h3><p>查看对象域的关键方法是Field类中的get方法。如果f是一个Field类型的对象，obj是某个包含f域的类的对象，f.get(obj)将返回一个对象，其值为obj 的f域当前的值。<br>看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student() ;</span><br><span class="line">stu.setId(<span class="string">"15198"</span>);</span><br><span class="line"><span class="comment">//获取Field对象</span></span><br><span class="line">Field f2 = stu.getClass().getDeclaredField(<span class="string">"id"</span>) ;</span><br><span class="line"><span class="comment">//由于id在Student类中是收到访问保护的，所以调用这个方法覆盖访问控制</span></span><br><span class="line">f2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(f2.get(stu).toString());</span><br><span class="line"><span class="comment">//输出：15198</span></span><br></pre></td></tr></table></figure><p>如果类中有double类型的域，可以使用Field类中的getDouble方法，也可以调用get方法，这时候反射机制将会自动将这个域值打包到相应的对象包装器中。<br>可以获得当然也可以设置，调用f.set(obj,value)就可以将obj对象的f域设置成value。</p><p><strong>java.lang.reflect.AccessibleObject类中的setAccessible(boolean flag)为反射对象设置可访问标志。flag为true表明屏蔽java语言的访问检查，是的对象的私有属性也可以被查询和设置。如果要设置的对象在一个数组里，可以调用AccessibleObject的静态方法setAccessible(accessibleObject[] array,boolean flag)来统一设置。（AccessibleObject是Field、Method和Constructor的超类）</strong></p><h3 id="使用反射机制调用任意方法"><a href="#使用反射机制调用任意方法" class="headerlink" title="使用反射机制调用任意方法"></a>使用反射机制调用任意方法</h3><p>与Field类的get方法类似，在Method类中有一个invoke方法，它允许调用包装在当前Method对象中的方法。<br>Object invoke(Object obj,Object… args)<br>第一个参数是隐式对象，如果Method对象是一个静态方法，obj设置为null。<br>其余对象提供了显式参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student() ;</span><br><span class="line">stu.setId(<span class="string">"15198"</span>);</span><br><span class="line"><span class="comment">//获取方法对应的Method</span></span><br><span class="line">Method m = stu.getClass().getDeclaredMethod(<span class="string">"setId"</span>, <span class="keyword">new</span> Class[]&#123;String.class&#125;) ;</span><br><span class="line"><span class="comment">//调用invoke方法对id进行更改</span></span><br><span class="line">m.invoke(stu, <span class="string">"111111"</span>) ;</span><br><span class="line">Method mm = stu.getClass().getDeclaredMethod(<span class="string">"getId"</span>, <span class="keyword">new</span> Class[]&#123;&#125;) ;</span><br><span class="line">String id = (String) mm.invoke(stu, <span class="keyword">null</span>) ;</span><br><span class="line">System.out.println(id);</span><br><span class="line"><span class="comment">//输出：111111</span></span><br></pre></td></tr></table></figure><p>如果返回值是基本类型，invoke方法会返回其包装器类型。</p><p><strong>注意：invoke的参数和返回值必须是Object类型的，这就意味着必须进行多次的类型转换。这样做将会使编译器错过检查代码的机会。因此等到测试阶段才会发现这些错误，找到并改正将会更加困难，不仅如此，使用反射获得方法指针的代码要比仅仅直接调用方法明显要慢一些。<br>所以建议仅在必要的时候才使用Method对象。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反射库(reflection library)提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。特别是在设计或运行中添加类时，能够快速地应用开发工具动态地查询新添加类的能力。&lt;br&gt;能够分析类能力的程序称为反射(reflective)，反射机制的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring配置文件</title>
    <link href="http://yoursite.com/2018/07/07/Spring%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/07/07/Spring初体验/</id>
    <published>2018-07-07T12:19:02.000Z</published>
    <updated>2018-07-07T15:07:00.153Z</updated>
    
    <content type="html"><![CDATA[<p>emmm使用Spring写的第一个web程序就GG了，查了一下是我的springmvc-config.xml文件写的不对，把这个模板记录一下吧。</p><p>web.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 项目名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>SpringMVCTest<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/springmvc-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>springmvc-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 处理映射器将bean的name作为URL进行查找，需要在配置handle时指定name（URL） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SimpleControllerHandlerAdapter是一个处理器适配器，所有处理器适配器都要实现HandlerAdapter接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用注解类型的springmvc-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-4.2.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring可以自动去扫描base-package下面的包或子包下面的Java文件，</span></span><br><span class="line"><span class="comment">如果扫描到有spring相关注解的类，则把这些类注册为spring的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"packagename"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置annotation类型的处理映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置annotation类型的处理器适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;emmm使用Spring写的第一个web程序就GG了，查了一下是我的springmvc-config.xml文件写的不对，把这个模板记录一下吧。&lt;/p&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring框架配置过程</title>
    <link href="http://yoursite.com/2018/07/07/Spring%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/07/Spring框架配置过程/</id>
    <published>2018-07-07T11:26:12.000Z</published>
    <updated>2018-07-07T12:16:01.184Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始学习SSM（Spring、SpringMVC、MYBatis）框架，记录一下配置Spring框架的过程，防止以后踩坑。</p><h3 id="一、下载Spring以及Apache的commons-logging"><a href="#一、下载Spring以及Apache的commons-logging" class="headerlink" title="一、下载Spring以及Apache的commons-logging"></a>一、下载Spring以及Apache的commons-logging</h3><p>Spring 下载地址：<a href="http://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">http://repo.spring.io/release/org/springframework/spring/</a><br>commons-logging下载地址：<a href="http://commons.apache.org/proper/commons-logging/download_logging.cgi" target="_blank" rel="noopener">http://commons.apache.org/proper/commons-logging/download_logging.cgi</a></p><h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>将两个压缩包解压，在eclipse的workspace下新建一个文件夹，名字任意，我新建了一个名为lib的文件夹，将spring解压后的文件夹根目录下的libs文件夹下的所有jar包复制到lib文件夹里面，然后将commons-logging文件夹下的<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-1.png" alt="文件"><br>也复制到lib文件夹下。</p><h3 id="三、在Eclipse里设置"><a href="#三、在Eclipse里设置" class="headerlink" title="三、在Eclipse里设置"></a>三、在Eclipse里设置</h3><p>打开windows==&gt;preferences==&gt;Java==&gt;Build Path==&gt;User Libraries<br>如图：<img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-2.png" alt=""><br>点击new,然后输入一个名称点击确定。<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-3.png" alt=""><br> 然后下一步鼠标单击选中刚刚新建好的Library，点击右侧Add External JARs，找到我们之前在eclipse的workspace里新建好的lib文件夹，点进去全选jar包接着点击确定，这时候我们新建的Library以及有很多我们添加的jar包了。</p><h3 id="四、在web项目导入Library"><a href="#四、在web项目导入Library" class="headerlink" title="四、在web项目导入Library"></a>四、在web项目导入Library</h3><p> 右键点击web项目选择Build Path==&gt;configure Build Path<br> 进入如下界面点击Add Library<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-4.png" alt=""></p><p> 然后：选择User Library 点击Next<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-5.png" alt=""></p><p> 再然后选择我们新建的Library 点击Finish就行啦<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-6.png" alt=""></p><p> 然后就可以看到我们的项目中已经导入进去这个Library了<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-8.png" alt=""></p><p> 不过做完这些我还是没有运行成功，上网查了一下还需要一个步骤</p><h3 id="五、最后一步（Spring配置）"><a href="#五、最后一步（Spring配置）" class="headerlink" title="五、最后一步（Spring配置）"></a>五、最后一步（Spring配置）</h3><p> 右键项目选择properties==&gt;Deployment Assem,点击后如下图所示<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-9.png" alt=""><br> 点击Add<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-10.png" alt=""><br> 选择Java Build Path Entries点击next：<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-11.png" alt=""><br> 选中我们刚才导进去的Library点击Finish就完成了<br> 效果：<br> <img src="http://osyvt66as.bkt.clouddn.com/2018-07-07-12.png" alt=""><br> 可以看到这里的Library已经显示出来了。</p><h4 id="至此Spring框架已经基本配置完成了"><a href="#至此Spring框架已经基本配置完成了" class="headerlink" title="至此Spring框架已经基本配置完成了"></a>至此Spring框架已经基本配置完成了</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚开始学习SSM（Spring、SpringMVC、MYBatis）框架，记录一下配置Spring框架的过程，防止以后踩坑。&lt;/p&gt;
&lt;h3 id=&quot;一、下载Spring以及Apache的commons-logging&quot;&gt;&lt;a href=&quot;#一、下载Spring以及Apac
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 大数类</title>
    <link href="http://yoursite.com/2018/07/06/Java-%E5%A4%A7%E6%95%B0%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/07/06/Java-大数类/</id>
    <published>2018-07-06T12:59:36.000Z</published>
    <updated>2018-07-06T14:06:22.088Z</updated>
    
    <content type="html"><![CDATA[<p>在编写程序当的时候，我们经常会遇到基本的整数和浮点数精度不能满足需求，那么可以使用Java.math 包中的两个十分有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现了任意精度的整数计算，BigDecimal实现了任意精度的浮点数运算。<br>这两个类包含的方法、提供的操作与对基本类型所能执行的操作相似，只不过是以方法调用方式取代运算符方式来实现。等于是用速度换取了精度。<br>它们都扩展Number类且实现Comparable接口，可以使用new BigInteger(String)或new BigDecimal(String)来创建实例，使用add，substract，multiple，divide和remainder方法完成算数运算，使用compareTo方法比较两个大数字。<br>java.util包中的Scanner类实现了nextBigInteger()和nextBigDecimal()方法，可以用来读入控制台输入的BigInteger和BigDecimal。</p><h2 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h4 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h4><table><thead><tr><th>Modifier and Type</th><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>BigInteger</td><td>ONE</td><td>BigInteger常数1</td></tr><tr><td>BigInteger</td><td>TEN</td><td>BigInteger常数10</td></tr><tr><td>BigInteger</td><td>ZERO</td><td>BigInteger常数0</td></tr></tbody></table><h4 id="常用构造方法："><a href="#常用构造方法：" class="headerlink" title="常用构造方法："></a>常用构造方法：</h4><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>BigInteger</td><td>BigInteger(String val)</td><td>将BigInteger的十进制字符串表示形式转换为BigInteger。 字符串表示由一个可选的减号，后跟一个或多个十进制数字的序列组成。 字符到数字映射由Character.digit提供。 字符串可能不包含任何无关的字符（例如，空格）。</td></tr></tbody></table><h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>BigInteger</td><td>add(BigInteger other)</td><td>返回这个大整数和另一个大整数的和</td></tr><tr><td>BigInteger</td><td>subtract(BigInteger other)</td><td>返回这个大整数和另一个大整数的差</td></tr><tr><td>BigInteger</td><td>multiply(BigInteger other)</td><td>返回这个大整数和另一个大整数的积</td></tr><tr><td>BigInteger</td><td>divide(BigInteger other)</td><td>返回这个大整数和另一个大整数的商</td></tr><tr><td>BigInteger</td><td>mod(BigInteger other)</td><td>返回这个大整数和另一个大整数的余数</td></tr><tr><td>int</td><td>compareTo(BigInteger other)</td><td>如果这个大整数与另一个大整数other相等，返回0；如果这个大整数小鱼另一个大整数other，返回负数；否则返回正数</td></tr><tr><td>static BigInteger</td><td>valueOf(long x)</td><td>返回值等于x的大整数</td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = <span class="keyword">new</span> BigInteger(<span class="string">"101001020203929301121"</span>) ;</span><br><span class="line"> BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"87265211"</span>) ;</span><br><span class="line"> System.out.println(<span class="string">"a+b= "</span>+a.add(b).toString());</span><br><span class="line"> System.out.println(<span class="string">"a-b= "</span>+a.subtract(b).toString());</span><br><span class="line"> System.out.println(<span class="string">"a/b= "</span>+a.divide(b).toString());</span><br><span class="line"> System.out.println(<span class="string">"a*b= "</span>+a.multiply(b).toString());</span><br><span class="line"> System.out.println(<span class="string">"a%b= "</span>+a.mod(b));</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-06-3.png" alt="程序输出"></p><h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><p>对BigDecimal对象的精度没有限制。如果结果不能终止，那么divide方法会抛出ArithmeticException异常。但是，可以使用重载的divide(BigDecimal d,int scale,int roundingMode)方法来指定尺度和舍入方式来避免这个异常,这里的scale是指小数点后最小的整数位数.例如,下面的代码创建两个尺度为20，舍入方式为BigDecimal.ROUND_UP的BigDecimal对象。</p><h3 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h3><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><table><thead><tr><th></th><th>Constructor</th><th>Description</th></tr></thead><tbody><tr><td>BigDecimal</td><td>BigDecimal(BigInteger val)</td><td>将 BigInteger转换成 BigDecimal 。</td></tr><tr><td>BigDecimal</td><td>BigDecimal(char[] in)</td><td>一个转换的字符数组表示 BigDecimal成 BigDecimal ，接受字符作为的相同序列 BigDecimal(String)构造。</td></tr><tr><td>BigDecimal</td><td>BigDecimal(double val)</td><td>将 double转换为 BigDecimal ，这是 double的二进制浮点值的精确十进制表示。</td></tr><tr><td>BigDecimal</td><td>BigDecimal(int val)</td><td>将 int成 BigDecimal 。</td></tr><tr><td>BigDecimal</td><td>BigDecimal(long val)</td><td>将 long成 BigDecimal 。</td></tr><tr><td>BigDecimal</td><td>BigDecimal(String val)</td><td>将BigDecimal的字符串表示 BigDecimal转换为 BigDecimal 。</td></tr></tbody></table><h4 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h4><table><thead><tr><th>Modifier and Type</th><th>Method</th><th>Description</th></tr></thead><tbody><tr><td>BigDecimal</td><td>add(BigDecimal other)</td><td>返回这个大实数和另一个大实数的和</td></tr><tr><td>BigDecimal</td><td>subtract(BigDecimal other)</td><td>返回这个大实数和另一个大实数的差</td></tr><tr><td>BigDecimal</td><td>multiply(BigDecimalr other)</td><td>返回这个大实数和另一个大实数的积</td></tr><tr><td>BigDecimal</td><td>divide(BigDecimal other,RoundingMode roundingMode)</td><td>返回这个大实数和另一个大实数的商 ，并且按照roundingMode舍入模式</td></tr><tr><td>int</td><td>compareTo(BigDecimal other)</td><td>如果这个大实数与另一个大实数other相等，返回0；如果这个大实数小于另一个大整数other，返回负数；否则返回正数</td></tr><tr><td>static BigDecimal</td><td>valueOf(long x)</td><td>返回值为x的一个大实数</td></tr><tr><td>static BigDecimal</td><td>valueOf(long x，int scale)</td><td>返回值等于x/10的scale次幂的大实数</td></tr></tbody></table><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"2716217627162761.81728"</span>) ;</span><br><span class="line">   BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"12121.323"</span>) ;</span><br><span class="line">   System.out.println(<span class="string">"a+b= "</span>+a.add(b).toString());</span><br><span class="line">   System.out.println(<span class="string">"a-b= "</span>+a.subtract(b).toString());</span><br><span class="line">   System.out.println(<span class="string">"a/b= "</span>+a.divide(b,RoundingMode.HALF_UP).toString());<span class="comment">//舍入模式为四舍五入</span></span><br><span class="line">   System.out.println(<span class="string">"a*b= "</span>+a.multiply(b).toString());</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-06-4.png" alt="程序输出"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、商业计算使用BigDecimal。</p><p>2、尽量使用参数类型为String的构造函数。</p><p>2、 BigDecimal都是不可变的（immutable）的，在进行每一步运算时，都会产生一个新的对象，所以在做加减乘除运算时千万要保存操作后的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在编写程序当的时候，我们经常会遇到基本的整数和浮点数精度不能满足需求，那么可以使用Java.math 包中的两个十分有用的类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现了任意精度的整数计算，BigDec
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java引用传递和值传递</title>
    <link href="http://yoursite.com/2018/07/06/Java%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%92%8C%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/07/06/Java引用传递和值传递/</id>
    <published>2018-07-06T10:45:37.000Z</published>
    <updated>2018-07-06T12:07:20.087Z</updated>
    
    <content type="html"><![CDATA[<p>关于Java的引用传递和值传递，经常会混淆，但这个知识点却很重要。</p><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>1、值传递：方法调用时，实际参数把它的值传递给对应的形式参数，函数接收的是原始值的一个copy，此时内存中存在两个相等的基本类型，即实际参数和形式参数，后面方法中的操作都是对形参这个值的修改，不影响实际参数的值。<br>2、引用传递：也称为传地址。方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址；在方法执行中，形参和实参内容相同，指向同一块内存地址，方法执行中对引用的操作将会影响到实际对象。</p><p>以下是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    test a = <span class="keyword">new</span> test(<span class="string">"he"</span>) ;</span><br><span class="line">    test b = <span class="keyword">new</span> test(<span class="string">"en"</span>) ;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span> ;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span> ;</span><br><span class="line">    swap(x,y) ;</span><br><span class="line">    System.out.println(<span class="string">"x= "</span>+x+<span class="string">", y= "</span>+y);</span><br><span class="line">    swap(a,b) ;</span><br><span class="line">    System.out.println(a.name+<span class="string">"  "</span>+b.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(test x,test y)</span></span>&#123;</span><br><span class="line">    test temp = x ;</span><br><span class="line">    x = y ;</span><br><span class="line">    y = temp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp =a ;</span><br><span class="line">    a = b ;</span><br><span class="line">    b = temp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    String name ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name ;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个程序输出：<br><img src="http://osyvt66as.bkt.clouddn.com/@KO~G%600NS9WVWF5~QPLC%60$S.png" alt="程序输出"></p><p>可以看到虽然调用了swap方法，并没有发生交换。</p><p>再看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">   String s = <span class="string">"hello"</span> ;</span><br><span class="line">   StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"helllo"</span>) ;</span><br><span class="line">   change(s) ;</span><br><span class="line">   change(sb) ;</span><br><span class="line">   System.out.println(s);</span><br><span class="line">   System.out.println(sb.toString());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">   str += <span class="string">"hello"</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(StringBuilder s)</span></span>&#123;</span><br><span class="line">   s.append(<span class="string">"hello"</span>) ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个程序的输出：<br><img src="http://osyvt66as.bkt.clouddn.com/2018-07-06-2.png" alt="程序输出"><br>这里看到StringBuilder内容却发生了改变。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上面的程序可以得出结论：<br>1、基本数据类型传值，对形参的修改不会影响实参；<br>2、引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；<br>3、String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于Java的引用传递和值传递，经常会混淆，但这个知识点却很重要。&lt;/p&gt;
&lt;h3 id=&quot;值传递和引用传递&quot;&gt;&lt;a href=&quot;#值传递和引用传递&quot; class=&quot;headerlink&quot; title=&quot;值传递和引用传递&quot;&gt;&lt;/a&gt;值传递和引用传递&lt;/h3&gt;&lt;p&gt;1、值传递
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对象包装器和String</title>
    <link href="http://yoursite.com/2018/07/06/%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8/"/>
    <id>http://yoursite.com/2018/07/06/对象包装器/</id>
    <published>2018-07-06T07:48:59.294Z</published>
    <updated>2018-07-06T09:23:47.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象包装器与自动装箱"><a href="#对象包装器与自动装箱" class="headerlink" title="对象包装器与自动装箱"></a>对象包装器与自动装箱</h2><p>有时，需要将int这样的基本数据类型装换为对象。所有的基本类型都有一个与之对应的类。这些对象包装器类都有很鲜明的名字：Integer、Long、Double、Short、Byte、Character、Void和Boolean(前6个类派生与公共的超类Number）。对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时对象包装器类还是final，因此不能定义它们的子类。</p><p>警告：由于每个值分别包装在对象中，所以ArrayList<integer>的效率远远低于int[]数组。因此，应该用它构造小型集合，其原因是此时程序员操作的方便性要比执行效率更加重要。</integer></p><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(3) ;</span><br></pre></td></tr></table></figure><p>将自动变换成<code>list.add(Integer.valueOf(3)) ;</code>这种变换称为自动装箱(autoboxing）。<br>相反的，当将一个Integer对象赋给一个int值时，将会自动拆箱。也就是说，编译器将下列语句：<code>int n = list.get(i) ；</code>翻译成<code>int n = list.get(i).intValueOf() ;</code><br>甚至在算术表达式中也能自动装箱和拆箱。例如：可以将自增操作符应用于一个包装器引用：<code>Integer n = 3 ; n++ ;</code>编译器将自动插入一条对象拆箱的指令，然后进行自增运算，最后将结果装箱。</p><p>在很多情况下，容易有一个错觉，即基本类型与它们的 对象包装器是一样的，只是它们的相等性不同。大家知道，==运算符也可以应用于对象包装器对象，只不过检测的是是否指向同一个存储区域，所以下面这种比较通常不成立：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1000</span> ;</span><br><span class="line">Integer b = <span class="number">1000</span> ;</span><br><span class="line"><span class="keyword">if</span>(a ==b)</span><br></pre></td></tr></table></figure></p><p>所以在比较两个包装器对象时应该调用equals方法。<br>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。虚拟机只是执行这些字节码。</p><h2 id="String、StringBuilder和StringBuffer"><a href="#String、StringBuilder和StringBuffer" class="headerlink" title="String、StringBuilder和StringBuffer"></a>String、StringBuilder和StringBuffer</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>1、String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。在Java中，被final修饰的类是不允许被继承的，并且该类中的成员方法都默认为final方法。在早期的JVM实现版本中，被final修饰的方法会被转为内嵌调用以提升执行效率。而从Java SE5/6开始，就渐渐摈弃这种方式了。因此在现在的Java SE版本中，不需要考虑用final去提升方法调用效率。只有在确定不想让该方法被覆盖时，才将方法设置为final。<br>2、String类其实通过char数组来保存字符串的。无论是sub操、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。即：对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象</p><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>Java语言允许使用’+‘号连接（拼接）两个字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span> ;</span><br><span class="line">String str2 = <span class="string">" world!"</span> ;</span><br><span class="line">String str = str1+str2 ;</span><br></pre></td></tr></table></figure></p><p>这段代码将str1和str2拼接起来赋值给str。<br>当将一个字符串与一个非字符串的值进行拼接时，后者被装换成字符串。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">13</span> ;</span><br><span class="line">String rating = <span class="string">"PG"</span>+age ;</span><br></pre></td></tr></table></figure></p><p>这段代码将rating设置为“PG13”。这个特性常用于输出语句中。例如：`System.out.println(“the answer is “+answer) ; 这是一条合法的语句。<br>关于字符串共享：String str1 = “hello world”;和String str3 = “hello world”; 都在编译期间生成了 字面常量和符号引用，运行期间字面常量”hello world”被存储在运行时常量池（当然只保存了一份）。通过这种方式来将String对象跟引用绑定的话，JVM执行引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接将引用指向已经存在的字面常量；否则在运行时常量池开辟一个空间来存储该字面常量，并将引用指向该字面常量。</p><p>　　总所周知，通过new关键字来生成对象是在堆区进行的，而在堆区进行对象生成的过程是不会去检测该对象是否已经存在的。因此通过new来创建对象，创建出的一定是不同的对象，即使字符串的内容是相同的</p><h4 id="String、StringBuffer、StringBuilder"><a href="#String、StringBuffer、StringBuilder" class="headerlink" title="String、StringBuffer、StringBuilder"></a>String、StringBuffer、StringBuilder</h4><p>String、StringBuilder、StringBuffer三者的执行效率：StringBuilder &gt; StringBuffer &gt; String  当然这个是相对的，不一定在所有情况下都是这样。<br>比如<code>String str = &quot;hello&quot;+ &quot;world&quot;</code>的效率比<code>StringBuilder st  = new StringBuilder().append(&quot;hello&quot;).append(&quot;world&quot;)</code>要高。<br>因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用：当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer</p><p>在JDK5.0中引入StringBuilder类。这个类的前身是StringBuffer，其效率稍有些低，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中编辑，则应该用StringBuilder替代它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象包装器与自动装箱&quot;&gt;&lt;a href=&quot;#对象包装器与自动装箱&quot; class=&quot;headerlink&quot; title=&quot;对象包装器与自动装箱&quot;&gt;&lt;/a&gt;对象包装器与自动装箱&lt;/h2&gt;&lt;p&gt;有时，需要将int这样的基本数据类型装换为对象。所有的基本类型都有一个与之对
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Objecct类</title>
    <link href="http://yoursite.com/2018/07/06/%E5%85%B3%E4%BA%8EObjecct%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/07/06/关于Objecct类/</id>
    <published>2018-07-06T06:39:29.000Z</published>
    <updated>2018-07-06T06:40:16.330Z</updated>
    
    <content type="html"><![CDATA[<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类中的equals方法用于检测一个对象是否等于另一个对象，在Object类中这个方法判断两个对象是否具有相同的引用。<br>在子类中定义equals方法时，首先调用超类的equals方法。如果检测失败，对象就不相等。如果超类中的域都相等，就需要比较子类中的实例域。</p><h3 id="相等测试与继承"><a href="#相等测试与继承" class="headerlink" title="相等测试与继承"></a>相等测试与继承</h3><h4 id="Java语言规范要求equals方法具有以下特性"><a href="#Java语言规范要求equals方法具有以下特性" class="headerlink" title="Java语言规范要求equals方法具有以下特性"></a>Java语言规范要求equals方法具有以下特性</h4><p>1、自反性：对于任何非空引用x，x.equals(x)应该返回true。<br>2、对称性：对于他任何引用x,y,当且仅当y.equals(x)返回true，x.equals(y)也应该返回true。<br>3、传递性：对于任何引用x,y和z,如果x.equals(y)返回true,y.equals(z)返回true,那么x.equals(z)也应该返回true。<br>4、一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回相同的结果。<br>5、对于任意非空引用x，x.equals(null)应该返回false。</p><h4 id="编写一个完美equals方法建议"><a href="#编写一个完美equals方法建议" class="headerlink" title="编写一个完美equals方法建议"></a>编写一个完美equals方法建议</h4><p>假设显示参数命名为otherObject(稍后会被转换成一个叫做other的变量）<br>1、检测this与otherObject是否引用同一个对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span> ;</span><br></pre></td></tr></table></figure></p><p>这条语句只是一个优化。实际上这是一种经常采用的形式。因为计算这个等式要比一个一个比较类中的域所付出的代价要小很多。<br>2、检测otherObject是否为null，如果为null，返回false。这个检测是很有必要的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(otherObject == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span> ;</span><br></pre></td></tr></table></figure></p><p>3、比较this与otherObject是否属于同一个类，如果equals的语义在每个子类中有所改变，就使用getclass检测：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass() != otherObject.getClass()) <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br></pre></td></tr></table></figure></p><p>如果所有的子类都有统一的语义，就使用instanceof检测：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName)) <span class="keyword">return</span> <span class="keyword">false</span> ;</span><br></pre></td></tr></table></figure></p><p>4、将otherObject转换为相应的类类型变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName other = (ClassName)otehrObject</span><br></pre></td></tr></table></figure></p><p>5、现在开始对所有需要比较的域进行比较了。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，返回true，否则返回false。如果在子类中重新定义equals，就要在七种包含调用super.equals(other)。</p><p>注：对于数组类型的域，可以使用静态的Arrays.equals方法检测相应的数组元素是否相等。</p><h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode 方法"></a>hashCode 方法</h2><p>散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。如果x和y是两个不同的对象，x.hashCode()与y.hashCode()基本不会相同.</p><p>String散列码计算算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">int</span> hash = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">hash = <span class="number">31</span>*hash+s.charAt(i) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于hashCode方法定义在Object类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ok"</span> ;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(s) ;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">hash = <span class="number">31</span>*hash+s.charAt(i) ;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hash);</span><br><span class="line">System.out.println(s.hashCode()+<span class="string">" "</span>+sb.hashCode());</span><br></pre></td></tr></table></figure></p><p>输出结果：<br>3548<br>3548 366712642<br>因为StringBuilder类中没有重新定义hashCode方法，它的散列码是由Object类的默认hashCode方法导出的对象存储地址。<br>如果重新定义equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中。</p><p>equals与hashCode定义必须一致：如果x.equals(y)返回true，那么x.hashCode()就必须与y.hashCode()具有相同值。<br>注：如果存在数组类型的域。那么可以使用静态的Arrays.hashCode方法计算一个散列码，这个散列码由数组元素的散列码组成。</p><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>在Object中海油同一个重要的方法，就是toString方法：用于返回表示对象值得字符串。<br>如果没有重新定义toString方法，调用将会使用Object的toStirng方法，打印输出对象的类名和散列码。<br>若果x是任意一个对象，并调用：<code>System.out.println(x);</code>  println方法就会直接调用x.toString()，并打印输出得到的字符串。<br>数组继承了Object的toStirng方法，所以对数组调用toString会返回类名的散列码，这时候应该调用静态方法Arrays.toString(arrname)。打印多维数组则需要调用Arrays.deepToString方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;equals方法&quot;&gt;&lt;a href=&quot;#equals方法&quot; class=&quot;headerlink&quot; title=&quot;equals方法&quot;&gt;&lt;/a&gt;equals方法&lt;/h2&gt;&lt;p&gt;Object类中的equals方法用于检测一个对象是否等于另一个对象，在Object类中这个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Struts 2 输入校验</title>
    <link href="http://yoursite.com/2018/07/06/2017-07-12-strut_2/"/>
    <id>http://yoursite.com/2018/07/06/2017-07-12-strut_2/</id>
    <published>2018-07-06T03:14:23.358Z</published>
    <updated>2018-07-05T06:45:07.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在此之前我们要明确一个问题：我们为什么要输入校验"><a href="#在此之前我们要明确一个问题：我们为什么要输入校验" class="headerlink" title="在此之前我们要明确一个问题：我们为什么要输入校验?"></a>在此之前我们要明确一个问题：我们为什么要输入校验?</h3><p>   对于一个web应用而言，用户数据都是通过客户端收集的，用户的输入信息是非常复杂的，比如用户输入不熟练，输入出错，或者硬件设备不正常，网络情况，甚至恶意输入等都会导致输入异常。<br>   异常输入，轻则导致系统非正常中断，重则导致系统崩溃。应用程序必须正确的处理哦用户的输入，将一些错误的输入挡在门外！对异常输入进行过于，就是输入校验。</p><h2 id="校验分为客户端校验和服务器端校验"><a href="#校验分为客户端校验和服务器端校验" class="headerlink" title="校验分为客户端校验和服务器端校验"></a>校验分为客户端校验和服务器端校验</h2><h3 id="客户端校验"><a href="#客户端校验" class="headerlink" title="客户端校验"></a>客户端校验</h3><p>  以一个简单的注册界面为例，该页面的额表单有四个用户输入，分别为用户名，密码，生日和年龄，使用一个JavaScript进行客户端校验，校验规则为：1、用户名：必填项；必须是字母和数字且长度为4-25。2、密码：必填项；必须是字幕和数字且长度在4-25之间。3、年龄：必填项；必须是一个有效的年龄值。4、生日：必填项；生日必须是一个有效的日期，且只能是19xx年或者20xx年，格式为yyyy-mm-dd。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="regexp">/^\s+/</span> , <span class="string">""</span>)</span><br><span class="line">.replace(<span class="regexp">/\s+$/</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 校验表单的JavaScript函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params">form</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 定义错误字符串</span></span><br><span class="line"><span class="keyword">var</span> errStr = <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 依次取出表单中的四个表单域的值</span></span><br><span class="line"><span class="keyword">var</span> username = form.name.value.trim();</span><br><span class="line"><span class="keyword">var</span> pass = form.pass.value.trim();</span><br><span class="line"><span class="keyword">var</span> age = form.age.value.trim();</span><br><span class="line"><span class="keyword">var</span> birth = form.birth.value.trim();</span><br><span class="line"><span class="comment">// 判断用户名不能为空</span></span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">""</span> || name == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"您的用户名必须输入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断用户名必须是数字和字母，且长度必须为4到25之间</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^\w&#123;4,25&#125;$/</span>.test(name))</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的用户名必须是字母和数字，且长度在4到25之间"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断密码必须输入</span></span><br><span class="line"><span class="keyword">if</span> (pass == <span class="string">""</span> || pass == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的密码必须输入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断密码必须是数字和字母，且长度必须为4到25之间</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^\w&#123;4,25&#125;$/</span>.test(pass))</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的密码必须是字母和数字，且长度在4到25之间"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断年龄必须输入</span></span><br><span class="line"><span class="keyword">if</span> (age == <span class="string">""</span> || age == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的年龄必须输入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断年龄必须是一个有效的年龄</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^[0-1]?[0-9]?[0-9]$/</span>.test(age))</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的年龄必须为整数，且必须是一个有效的年龄值"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断生日必须输入</span></span><br><span class="line"><span class="keyword">if</span> (birth == <span class="string">""</span> || birth == <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的生日必须输入"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断生日必须是一个有效的日期，且只能是19xx年，或者20xx年</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!<span class="regexp">/^19\d\d\-[0-1]\d\-[0-3]\d$/</span>.test(birth) </span><br><span class="line">&amp;&amp; !<span class="regexp">/^20[0-1]\d\-[0-1]\d\-[0-3]\d$/</span>.test(birth))</span><br><span class="line">&#123;</span><br><span class="line">errStr += <span class="string">"\n您的生日格式不正确,格式：yyyy-MM-DD"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果错误字符串为空，表明客户端校验通过</span></span><br><span class="line"><span class="keyword">if</span> (errStr == <span class="string">""</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端校验没有通过，通过警告框输出校验失败提示</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alert(errStr);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>$&#123;error&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s:form</span> <span class="attr">action</span>=<span class="string">"regist"</span> <span class="attr">onsubmit</span>=<span class="string">"return validate(this);"</span>&gt;</span></span><br><span class="line">用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">密&amp;nbsp;&amp;nbsp;码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"pass"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">生&amp;nbsp;&amp;nbsp;日：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"birth"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">年&amp;nbsp;&amp;nbsp;龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"注册"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">s:form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://osyvt66as.bkt.clouddn.com/client_1.png" alt="代码效果"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在此之前我们要明确一个问题：我们为什么要输入校验&quot;&gt;&lt;a href=&quot;#在此之前我们要明确一个问题：我们为什么要输入校验&quot; class=&quot;headerlink&quot; title=&quot;在此之前我们要明确一个问题：我们为什么要输入校验?&quot;&gt;&lt;/a&gt;在此之前我们要明确一个问题
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>my-first-blog </title>
    <link href="http://yoursite.com/2018/07/06/my-first-blog/"/>
    <id>http://yoursite.com/2018/07/06/my-first-blog/</id>
    <published>2018-07-05T17:13:38.000Z</published>
    <updated>2018-07-05T17:13:39.005Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
